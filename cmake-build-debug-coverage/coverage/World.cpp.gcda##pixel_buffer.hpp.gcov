        -:    0:Source:/home/dihydromonoxide/vcpkg/installed/x64-linux/include/png++/pixel_buffer.hpp
        -:    0:Graph:/home/dihydromonoxide/CLionProjects/Raytracer/cmake-build-debug-coverage/CMakeFiles/Raytracer.dir/src/World.cpp.gcno
        -:    0:Data:/home/dihydromonoxide/CLionProjects/Raytracer/cmake-build-debug-coverage/CMakeFiles/Raytracer.dir/src/World.cpp.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: * Copyright (C) 2007,2008   Alex Shulgin
        -:    3: *
        -:    4: * This file is part of png++ the C++ wrapper for libpng.  PNG++ is free
        -:    5: * software; the exact copying conditions are as follows:
        -:    6: *
        -:    7: * Redistribution and use in source and binary forms, with or without
        -:    8: * modification, are permitted provided that the following conditions are met:
        -:    9: *
        -:   10: * 1. Redistributions of source code must retain the above copyright notice,
        -:   11: * this list of conditions and the following disclaimer.
        -:   12: *
        -:   13: * 2. Redistributions in binary form must reproduce the above copyright
        -:   14: * notice, this list of conditions and the following disclaimer in the
        -:   15: * documentation and/or other materials provided with the distribution.
        -:   16: *
        -:   17: * 3. The name of the author may not be used to endorse or promote products
        -:   18: * derived from this software without specific prior written permission.
        -:   19: *
        -:   20: * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
        -:   21: * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
        -:   22: * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
        -:   23: * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   24: * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
        -:   25: * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
        -:   26: * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
        -:   27: * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
        -:   28: * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   29: * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   30: */
        -:   31:#ifndef PNGPP_PIXEL_BUFFER_HPP_INCLUDED
        -:   32:#define PNGPP_PIXEL_BUFFER_HPP_INCLUDED
        -:   33:
        -:   34:#include <cassert>
        -:   35:#include <cstddef>
        -:   36:#include <stdexcept>
        -:   37:#include <vector>
        -:   38:
        -:   39:#include "packed_pixel.hpp"
        -:   40:#include "gray_pixel.hpp"
        -:   41:#include "index_pixel.hpp"
        -:   42:
        -:   43:namespace png
        -:   44:{
        -:   45:
        -:   46:    /**
        -:   47:     * \brief The pixel row traits class template.  Provides a common
        -:   48:     * way to get starting address of the row for packed and unpacked
        -:   49:     * row types.
        -:   50:     *
        -:   51:     * Not implemented--see specializations.
        -:   52:     */
        -:   53:    template< typename row > class row_traits;
        -:   54:
        -:   55:    /**
        -:   56:     * \brief The basic class template to represent image pixel data.
        -:   57:     */
        -:   58:    template< typename pixel,
        -:   59:              typename row,
        -:   60:              class traits = row_traits< row > >
        -:   61:    class basic_pixel_buffer
        -:   62:    {
        -:   63:    public:
        -:   64:        /**
        -:   65:         * \brief A row of pixel data.
        -:   66:         */
        -:   67:        typedef row row_type;
        -:   68:        typedef row_type& row_access;
        -:   69:        typedef row_type const& row_const_access;
        -:   70:        typedef traits row_traits;
        -:   71:
        -:   72:        /**
        -:   73:         * \brief Constructs an empty 0x0 pixel buffer object.
        -:   74:         */
function _ZN3png18basic_pixel_bufferINS_15basic_rgb_pixelIhEESt6vectorIS2_SaIS2_EENS_10row_traitsIS5_EEEC2Ev called 1 returned 100% blocks executed 100%
        1:   75:        basic_pixel_buffer()
        -:   76:            : m_width(0),
        1:   77:              m_height(0)
        1:   77-block  0
call    0 returned 1
        -:   78:        {
        1:   79:        }
        -:   80:
        -:   81:        /**
        -:   82:         * \brief Constructs an empty pixel buffer object.
        -:   83:         */
        -:   84:        basic_pixel_buffer(uint_32 width, uint_32 height)
        -:   85:            : m_width(0),
        -:   86:              m_height(0)
        -:   87:        {
        -:   88:            resize(width, height);
        -:   89:        }
        -:   90:
        -:   91:        uint_32 get_width() const
        -:   92:        {
        -:   93:            return m_width;
        -:   94:        }
        -:   95:
        -:   96:        uint_32 get_height() const
        -:   97:        {
        -:   98:            return m_height;
        -:   99:        }
        -:  100:
        -:  101:        /**
        -:  102:         * \brief Resizes the pixel buffer.
        -:  103:         *
        -:  104:         * If new width or height is greater than the original,
        -:  105:         * expanded pixels are filled with value of \a pixel().
        -:  106:         */
function _ZN3png18basic_pixel_bufferINS_15basic_rgb_pixelIhEESt6vectorIS2_SaIS2_EENS_10row_traitsIS5_EEE6resizeEjj called 1 returned 100% blocks executed 100%
        1:  107:        void resize(uint_32 width, uint_32 height)
        -:  108:        {
        1:  109:            m_width = width;
        1:  110:            m_height = height;
        1:  111:            m_rows.resize(height);
        1:  111-block  0
call    0 returned 1
      513:  112:            for (typename row_vec::iterator r = m_rows.begin();
call    0 returned 1
      513:  113:                 r != m_rows.end();
      513:  113-block  0
call    0 returned 513
call    1 returned 513
branch  2 taken 512 (fallthrough)
branch  3 taken 1
      512:  114:                 ++r)
      512:  114-block  0
call    0 returned 512
        -:  115:            {
      512:  116:                r->resize(width);
      512:  116-block  0
call    0 returned 512
call    1 returned 512
branch  2 taken 512 (fallthrough)
branch  3 taken 0 (throw)
        -:  117:            }
        1:  118:        }
        1:  118-block  0
        -:  119:
        -:  120:        /**
        -:  121:         * \brief Returns a reference to the row of image data at
        -:  122:         * specified index.
        -:  123:         *
        -:  124:         * Checks the index before returning a row: an instance of
        -:  125:         * std::out_of_range is thrown if \c index is greater than \c
        -:  126:         * height.
        -:  127:         */
function _ZN3png18basic_pixel_bufferINS_15basic_rgb_pixelIhEESt6vectorIS2_SaIS2_EENS_10row_traitsIS5_EEE7get_rowEm called 262656 returned 100% blocks executed 100%
   262656:  128:        row_access get_row(size_t index)
        -:  129:        {
   262656:  130:            return m_rows.at(index);
   262656:  130-block  0
call    0 returned 262656
        -:  131:        }
        -:  132:
        -:  133:        /**
        -:  134:         * \brief Returns a const reference to the row of image data at
        -:  135:         * specified index.
        -:  136:         *
        -:  137:         * The checking version.
        -:  138:         */
        -:  139:        row_const_access get_row(size_t index) const
        -:  140:        {
        -:  141:            return m_rows.at(index);
        -:  142:        }
        -:  143:
        -:  144:        /**
        -:  145:         * \brief The non-checking version of get_row() method.
        -:  146:         */
        -:  147:        row_access operator[](size_t index)
        -:  148:        {
        -:  149:            return m_rows[index];
        -:  150:        }
        -:  151:
        -:  152:        /**
        -:  153:         * \brief The non-checking version of get_row() method.
        -:  154:         */
        -:  155:        row_const_access operator[](size_t index) const
        -:  156:        {
        -:  157:            return m_rows[index];
        -:  158:        }
        -:  159:
        -:  160:        /**
        -:  161:         * \brief Replaces the row at specified index.
        -:  162:         */
        -:  163:        void put_row(size_t index, row_type const& r)
        -:  164:        {
        -:  165:            assert(r.size() == m_width);
        -:  166:            m_rows.at(index) = r;
        -:  167:        }
        -:  168:
        -:  169:        /**
        -:  170:         * \brief Returns a pixel at (x,y) position.
        -:  171:         */
        -:  172:        pixel get_pixel(size_t x, size_t y) const
        -:  173:        {
        -:  174:            return get_row(y).at(x);
        -:  175:        }
        -:  176:
        -:  177:        /**
        -:  178:         * \brief Replaces a pixel at (x,y) position.
        -:  179:         */
function _ZN3png18basic_pixel_bufferINS_15basic_rgb_pixelIhEESt6vectorIS2_SaIS2_EENS_10row_traitsIS5_EEE9set_pixelEmmS2_ called 262144 returned 100% blocks executed 100%
   262144:  180:        void set_pixel(size_t x, size_t y, pixel p)
        -:  181:        {
   262144:  182:            get_row(y).at(x) = p;
   262144:  182-block  0
call    0 returned 262144
call    1 returned 262144
   262144:  183:        }
        -:  184:
        -:  185:    protected:
        -:  186:        uint_32 m_width;
        -:  187:        uint_32 m_height;
        -:  188:        typedef std::vector< row_type > row_vec;
        -:  189:        row_vec m_rows;
        -:  190:    };
        -:  191:
        -:  192:    /**
        -:  193:     * \brief The row_traits specialization for unpacked pixel rows.
        -:  194:     */
        -:  195:    template< typename pixel >
        -:  196:    class row_traits< std::vector< pixel > >
        -:  197:    {
        -:  198:    public:
        -:  199:        /**
        -:  200:         * \brief Returns the starting address of the row.
        -:  201:         */
function _ZN3png10row_traitsISt6vectorINS_15basic_rgb_pixelIhEESaIS3_EEE8get_dataERS5_ called 512 returned 100% blocks executed 80%
      512:  202:        static pixel* get_data(std::vector< pixel >& vec)
        -:  203:        {
     512*:  204:            assert(vec.size());
      512:  204-block  0
call    0 returned 512
branch  1 taken 0 (fallthrough)
branch  2 taken 512
    %%%%%:  204-block  1
call    3 never executed
      512:  205:            return & vec[0];
      512:  205-block  0
call    0 returned 512
        -:  206:        }
        -:  207:    };
        -:  208:
        -:  209:    /**
        -:  210:     * The pixel_buffer specialization for unpacked pixels.
        -:  211:     */
        -:  212:    template< typename pixel >
        -:  213:    class pixel_buffer
        -:  214:        : public basic_pixel_buffer< pixel, std::vector< pixel > >
        -:  215:    {
        -:  216:    public:
function _ZN3png12pixel_bufferINS_15basic_rgb_pixelIhEEEC2Ev called 1 returned 100% blocks executed 100%
        1:  217:        pixel_buffer()
        1:  218:        {
        1:  218-block  0
call    0 returned 1
        1:  219:        }
        -:  220:
        -:  221:        pixel_buffer(uint_32 width, uint_32 height)
        -:  222:            : basic_pixel_buffer< pixel, std::vector< pixel > >(width, height)
        -:  223:        {
        -:  224:        }
        -:  225:    };
        -:  226:
        -:  227:    namespace detail
        -:  228:    {
        -:  229:
        -:  230:        template< class pixel, typename reference >
        -:  231:        class basic_packed_pixel_proxy
        -:  232:        {
        -:  233:        public:
        -:  234:            explicit basic_packed_pixel_proxy(reference ref)
        -:  235:                : m_ref(ref),
        -:  236:                  m_shift(0)
        -:  237:            {
        -:  238:            }
        -:  239:
        -:  240:            basic_packed_pixel_proxy(reference ref, size_t index)
        -:  241:                : m_ref(ref),
        -:  242:                  m_shift(get_shift(index))
        -:  243:            {
        -:  244:            }
        -:  245:
        -:  246:            operator pixel() const
        -:  247:            {
        -:  248:                return pixel((m_ref >> m_shift) & pixel::get_bit_mask());
        -:  249:            }
        -:  250:
        -:  251:        protected:
        -:  252:            /*
        -:  253:             * bits: . .   .
        -:  254:             *    1: 7 6 5 4 3 2 1 0
        -:  255:             *    2:   6   4   2   0
        -:  256:             *    4:       4       0
        -:  257:             */
        -:  258:            static size_t get_shift(size_t index)
        -:  259:            {
        -:  260:                int const bits = pixel::get_bit_depth();
        -:  261:                return (8 - bits) - (index % get_pixels_per_byte()) * bits;
        -:  262:            }
        -:  263:
        -:  264:            static size_t get_pixels_per_byte()
        -:  265:            {
        -:  266:                return 8 / pixel::get_bit_depth();
        -:  267:            }
        -:  268:
        -:  269:            reference m_ref;
        -:  270:            size_t m_shift;
        -:  271:        };
        -:  272:
        -:  273:        template< class pixel >
        -:  274:        class const_packed_pixel_proxy
        -:  275:            : public basic_packed_pixel_proxy< pixel, byte const& >
        -:  276:        {
        -:  277:        public:
        -:  278:            const_packed_pixel_proxy(byte const& ref, size_t index)
        -:  279:                : basic_packed_pixel_proxy< pixel, byte const& >(ref, index)
        -:  280:            {
        -:  281:            }
        -:  282:        };
        -:  283:
        -:  284:        template< class pixel >
        -:  285:        class packed_pixel_proxy
        -:  286:            : public basic_packed_pixel_proxy< pixel, byte& >
        -:  287:        {
        -:  288:        public:
        -:  289:            typedef basic_packed_pixel_proxy< pixel, byte& > basic_proxy;
        -:  290:
        -:  291:            packed_pixel_proxy(byte& ref, size_t index)
        -:  292:                : basic_proxy(ref, index)
        -:  293:            {
        -:  294:            }
        -:  295:
        -:  296:            packed_pixel_proxy(packed_pixel_proxy const& other)
        -:  297:                : basic_proxy(other.m_ref)
        -:  298:            {
        -:  299:                this->m_shift = other.m_shift;
        -:  300:            }
        -:  301:
        -:  302:            packed_pixel_proxy& operator=(packed_pixel_proxy const& other)
        -:  303:            {
        -:  304:                return *this = static_cast< pixel >(other);
        -:  305:            }
        -:  306:
        -:  307:            template< typename reference >
        -:  308:            packed_pixel_proxy&
        -:  309:            operator=(basic_packed_pixel_proxy< pixel, reference > const& other)
        -:  310:            {
        -:  311:                return *this = static_cast< pixel >(other);
        -:  312:            }
        -:  313:
        -:  314:            packed_pixel_proxy& operator=(pixel p)
        -:  315:            {
        -:  316:                this->m_ref = (this->m_ref
        -:  317:                    & ~(pixel::get_bit_mask() << this->m_shift))
        -:  318:                    | (p << this->m_shift);
        -:  319:
        -:  320:                return *this;
        -:  321:            }
        -:  322:        };
        -:  323:
        -:  324:    } // namespace detail
        -:  325:
        -:  326:    /**
        -:  327:     * \brief The packed pixel row class template.
        -:  328:     *
        -:  329:     * Stores the pixel row as a std::vector of byte-s, providing
        -:  330:     * access to individual packed pixels via proxy objects.
        -:  331:     */
        -:  332:    template< class pixel >
        -:  333:    class packed_pixel_row
        -:  334:    {
        -:  335:    public:
        -:  336:        /**
        -:  337:         * \brief Constructs a pixel row object for \c size packed pixels.
        -:  338:         */
        -:  339:        explicit packed_pixel_row(size_t size = 0)
        -:  340:        {
        -:  341:            resize(size);
        -:  342:        }
        -:  343:
        -:  344:        size_t size() const
        -:  345:        {
        -:  346:            return m_size;
        -:  347:        }
        -:  348:
        -:  349:        /**
        -:  350:         * \brief Resizes the pixel row to hold up to \c size packed pixels.
        -:  351:         */
        -:  352:        void resize(size_t size)
        -:  353:        {
        -:  354:            m_vec.resize(size / get_pixels_per_byte()
        -:  355:                         + (size % get_pixels_per_byte() ? 1 : 0));
        -:  356:            m_size = size;
        -:  357:        }
        -:  358:
        -:  359:        /**
        -:  360:         * \brief The immutable packed pixel proxy type.
        -:  361:         */
        -:  362:        typedef detail::const_packed_pixel_proxy< pixel > const_pixel_proxy;
        -:  363:
        -:  364:        /**
        -:  365:         * \brief The mutable packed pixel proxy type.
        -:  366:         */
        -:  367:        typedef detail::packed_pixel_proxy< pixel > pixel_proxy;
        -:  368:
        -:  369:        /**
        -:  370:         * \brief Returns an immutable proxy the to the pixel at \c
        -:  371:         * index.
        -:  372:         */
        -:  373:        const_pixel_proxy at(size_t index) const
        -:  374:        {
        -:  375:            return const_pixel_proxy(m_vec.at(index / get_pixels_per_byte()),
        -:  376:                                     index);
        -:  377:        }
        -:  378:
        -:  379:        /**
        -:  380:         * \brief Returns a mutable proxy the to the pixel at \c
        -:  381:         * index.
        -:  382:         */
        -:  383:        pixel_proxy at(size_t index)
        -:  384:        {
        -:  385:            return pixel_proxy(m_vec.at(index / get_pixels_per_byte()),
        -:  386:                               index);
        -:  387:        }
        -:  388:
        -:  389:        /**
        -:  390:         * \brief Returns an immutable proxy the to the pixel at \c
        -:  391:         * index.  The non-checking version.
        -:  392:         */
        -:  393:        const_pixel_proxy operator[](size_t index) const
        -:  394:        {
        -:  395:            return const_pixel_proxy(m_vec[index / get_pixels_per_byte()],
        -:  396:                                     index);
        -:  397:        }
        -:  398:
        -:  399:        /**
        -:  400:         * \brief Returns n mutable proxy the to the pixel at \c
        -:  401:         * index.  The non-checking version.
        -:  402:         */
        -:  403:        pixel_proxy operator[](size_t index)
        -:  404:        {
        -:  405:            return pixel_proxy(m_vec[index / get_pixels_per_byte()],
        -:  406:                               index);
        -:  407:        }
        -:  408:
        -:  409:        /**
        -:  410:         * \brief Returns the starting address of the row.
        -:  411:         */
        -:  412:        byte* get_data()
        -:  413:        {
        -:  414:            assert(m_vec.size());
        -:  415:            return & m_vec[0];
        -:  416:        }
        -:  417:
        -:  418:    private:
        -:  419:        static size_t get_pixels_per_byte()
        -:  420:        {
        -:  421:            return 8 / pixel::get_bit_depth();
        -:  422:        }
        -:  423:
        -:  424:        std::vector< byte > m_vec;
        -:  425:        size_t m_size;
        -:  426:    };
        -:  427:
        -:  428:    /**
        -:  429:     * \brief The row_traits class template specialization for packed
        -:  430:     * pixel row type.
        -:  431:     */
        -:  432:    template< typename pixel >
        -:  433:    class row_traits< packed_pixel_row< pixel > >
        -:  434:    {
        -:  435:    public:
        -:  436:        /**
        -:  437:         * \brief Returns the starting address of the row.
        -:  438:         */
        -:  439:        static byte* get_data(packed_pixel_row< pixel >& row)
        -:  440:        {
        -:  441:            return row.get_data();
        -:  442:        }
        -:  443:    };
        -:  444:
        -:  445:    /**
        -:  446:     * \brief The pixel buffer class template specialization for the
        -:  447:     * packed_gray_pixel type.
        -:  448:     */
        -:  449:    template< int bits >
        -:  450:    class pixel_buffer< packed_gray_pixel< bits > >
        -:  451:        : public basic_pixel_buffer< packed_gray_pixel< bits >,
        -:  452:                                     packed_pixel_row< packed_gray_pixel
        -:  453:                                                       < bits > > >
        -:  454:    {
        -:  455:    public:
        -:  456:        typedef packed_gray_pixel< bits > pixel_type;
        -:  457:        typedef packed_pixel_row< pixel_type > pixel_row_type;
        -:  458:
        -:  459:        pixel_buffer()
        -:  460:        {
        -:  461:        }
        -:  462:
        -:  463:        pixel_buffer(uint_32 width, uint_32 height)
        -:  464:            : basic_pixel_buffer< pixel_type,
        -:  465:                                  pixel_row_type >(width, height)
        -:  466:        {
        -:  467:        }
        -:  468:    };
        -:  469:
        -:  470:    /**
        -:  471:     * \brief The pixel buffer class template specialization for the
        -:  472:     * packed_index_pixel type.
        -:  473:     */
        -:  474:    template< int bits >
        -:  475:    class pixel_buffer< packed_index_pixel< bits > >
        -:  476:        : public basic_pixel_buffer< packed_index_pixel< bits >,
        -:  477:                                     packed_pixel_row< packed_index_pixel
        -:  478:                                                       < bits > > >
        -:  479:    {
        -:  480:    public:
        -:  481:        typedef packed_index_pixel< bits > pixel_type;
        -:  482:        typedef packed_pixel_row< pixel_type > pixel_row_type;
        -:  483:
        -:  484:        pixel_buffer()
        -:  485:        {
        -:  486:        }
        -:  487:
        -:  488:        pixel_buffer(uint_32 width, uint_32 height)
        -:  489:            : basic_pixel_buffer< pixel_type,
        -:  490:                                  pixel_row_type >(width, height)
        -:  491:        {
        -:  492:        }
        -:  493:    };
        -:  494:
        -:  495:} // namespace png
        -:  496:
        -:  497:#endif // PNGPP_PIXEL_BUFFER_HPP_INCLUDED
