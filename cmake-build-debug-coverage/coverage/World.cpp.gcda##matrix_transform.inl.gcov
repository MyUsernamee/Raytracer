        -:    0:Source:/home/dihydromonoxide/vcpkg/installed/x64-linux/include/glm/ext/matrix_transform.inl
        -:    0:Graph:/home/dihydromonoxide/CLionProjects/Raytracer/cmake-build-debug-coverage/CMakeFiles/Raytracer.dir/src/World.cpp.gcno
        -:    0:Data:/home/dihydromonoxide/CLionProjects/Raytracer/cmake-build-debug-coverage/CMakeFiles/Raytracer.dir/src/World.cpp.gcda
        -:    0:Runs:1
        -:    1:namespace glm
        -:    2:{
        -:    3:	template<typename genType>
        -:    4:	GLM_FUNC_QUALIFIER GLM_CONSTEXPR genType identity()
        -:    5:	{
        -:    6:		return detail::init_gentype<genType, detail::genTypeTrait<genType>::GENTYPE>::identity();
        -:    7:	}
        -:    8:
        -:    9:	template<typename T, qualifier Q>
        -:   10:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> translate(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
        -:   11:	{
        -:   12:		mat<4, 4, T, Q> Result(m);
        -:   13:		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
        -:   14:		return Result;
        -:   15:	}
        -:   16:
        -:   17:	template<typename T, qualifier Q>
        -:   18:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> rotate(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
        -:   19:	{
        -:   20:		T const a = angle;
        -:   21:		T const c = cos(a);
        -:   22:		T const s = sin(a);
        -:   23:
        -:   24:		vec<3, T, Q> axis(normalize(v));
        -:   25:		vec<3, T, Q> temp((T(1) - c) * axis);
        -:   26:
        -:   27:		mat<4, 4, T, Q> Rotate;
        -:   28:		Rotate[0][0] = c + temp[0] * axis[0];
        -:   29:		Rotate[0][1] = temp[0] * axis[1] + s * axis[2];
        -:   30:		Rotate[0][2] = temp[0] * axis[2] - s * axis[1];
        -:   31:
        -:   32:		Rotate[1][0] = temp[1] * axis[0] - s * axis[2];
        -:   33:		Rotate[1][1] = c + temp[1] * axis[1];
        -:   34:		Rotate[1][2] = temp[1] * axis[2] + s * axis[0];
        -:   35:
        -:   36:		Rotate[2][0] = temp[2] * axis[0] + s * axis[1];
        -:   37:		Rotate[2][1] = temp[2] * axis[1] - s * axis[0];
        -:   38:		Rotate[2][2] = c + temp[2] * axis[2];
        -:   39:
        -:   40:		mat<4, 4, T, Q> Result;
        -:   41:		Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
        -:   42:		Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
        -:   43:		Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
        -:   44:		Result[3] = m[3];
        -:   45:		return Result;
        -:   46:	}
        -:   47:
        -:   48:	template<typename T, qualifier Q>
        -:   49:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> rotate_slow(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
        -:   50:	{
        -:   51:		T const a = angle;
        -:   52:		T const c = cos(a);
        -:   53:		T const s = sin(a);
        -:   54:		mat<4, 4, T, Q> Result;
        -:   55:
        -:   56:		vec<3, T, Q> axis = normalize(v);
        -:   57:
        -:   58:		Result[0][0] = c + (static_cast<T>(1) - c)      * axis.x     * axis.x;
        -:   59:		Result[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;
        -:   60:		Result[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;
        -:   61:		Result[0][3] = static_cast<T>(0);
        -:   62:
        -:   63:		Result[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;
        -:   64:		Result[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;
        -:   65:		Result[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;
        -:   66:		Result[1][3] = static_cast<T>(0);
        -:   67:
        -:   68:		Result[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;
        -:   69:		Result[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;
        -:   70:		Result[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;
        -:   71:		Result[2][3] = static_cast<T>(0);
        -:   72:
        -:   73:		Result[3] = vec<4, T, Q>(0, 0, 0, 1);
        -:   74:		return m * Result;
        -:   75:	}
        -:   76:
        -:   77:	template<typename T, qualifier Q>
        -:   78:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> scale(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
        -:   79:	{
        -:   80:		mat<4, 4, T, Q> Result;
        -:   81:		Result[0] = m[0] * v[0];
        -:   82:		Result[1] = m[1] * v[1];
        -:   83:		Result[2] = m[2] * v[2];
        -:   84:		Result[3] = m[3];
        -:   85:		return Result;
        -:   86:	}
        -:   87:
        -:   88:	template<typename T, qualifier Q>
        -:   89:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> scale_slow(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
        -:   90:	{
        -:   91:		mat<4, 4, T, Q> Result(T(1));
        -:   92:		Result[0][0] = v.x;
        -:   93:		Result[1][1] = v.y;
        -:   94:		Result[2][2] = v.z;
        -:   95:		return m * Result;
        -:   96:	}
        -:   97:
        -:   98:	template<typename T, qualifier Q>
function _ZN3glm8lookAtRHIfLNS_9qualifierE0EEENS_3matILi4ELi4ET_XT0_EEERKNS_3vecILi3ES3_XT0_EEES8_S8_ called 2 returned 100% blocks executed 95%
        2:   99:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> lookAtRH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
        -:  100:	{
        2:  101:		vec<3, T, Q> const f(normalize(center - eye));
        2:  101-block  0
call    0 returned 2
call    1 returned 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0 (throw)
    $$$$$:  101-block  1
        2:  102:		vec<3, T, Q> const s(normalize(cross(f, up)));
        2:  102-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  102-block  1
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0 (throw)
    $$$$$:  102-block  2
        2:  103:		vec<3, T, Q> const u(cross(s, f));
        2:  103-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:  104:
        2:  105:		mat<4, 4, T, Q> Result(1);
        2:  106:		Result[0][0] = s.x;
        2:  106-block  0
call    0 returned 2
call    1 returned 2
        2:  107:		Result[1][0] = s.y;
call    0 returned 2
call    1 returned 2
        2:  108:		Result[2][0] = s.z;
call    0 returned 2
call    1 returned 2
        2:  109:		Result[0][1] = u.x;
call    0 returned 2
call    1 returned 2
        2:  110:		Result[1][1] = u.y;
call    0 returned 2
call    1 returned 2
        2:  111:		Result[2][1] = u.z;
call    0 returned 2
call    1 returned 2
        2:  112:		Result[0][2] =-f.x;
call    0 returned 2
call    1 returned 2
        2:  113:		Result[1][2] =-f.y;
call    0 returned 2
call    1 returned 2
        2:  114:		Result[2][2] =-f.z;
call    0 returned 2
call    1 returned 2
        2:  115:		Result[3][0] =-dot(s, eye);
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  115-block  0
call    3 returned 2
call    4 returned 2
        2:  116:		Result[3][1] =-dot(u, eye);
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  116-block  0
call    3 returned 2
call    4 returned 2
        2:  117:		Result[3][2] = dot(f, eye);
call    0 returned 2
call    1 returned 2
call    2 returned 2
branch  3 taken 2 (fallthrough)
branch  4 taken 0 (throw)
        4:  118:		return Result;
        2:  118-block  0
        2:  118-block  1
        -:  119:	}
        -:  120:
        -:  121:	template<typename T, qualifier Q>
        -:  122:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> lookAtLH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
        -:  123:	{
        -:  124:		vec<3, T, Q> const f(normalize(center - eye));
        -:  125:		vec<3, T, Q> const s(normalize(cross(up, f)));
        -:  126:		vec<3, T, Q> const u(cross(f, s));
        -:  127:
        -:  128:		mat<4, 4, T, Q> Result(1);
        -:  129:		Result[0][0] = s.x;
        -:  130:		Result[1][0] = s.y;
        -:  131:		Result[2][0] = s.z;
        -:  132:		Result[0][1] = u.x;
        -:  133:		Result[1][1] = u.y;
        -:  134:		Result[2][1] = u.z;
        -:  135:		Result[0][2] = f.x;
        -:  136:		Result[1][2] = f.y;
        -:  137:		Result[2][2] = f.z;
        -:  138:		Result[3][0] = -dot(s, eye);
        -:  139:		Result[3][1] = -dot(u, eye);
        -:  140:		Result[3][2] = -dot(f, eye);
        -:  141:		return Result;
        -:  142:	}
        -:  143:
        -:  144:	template<typename T, qualifier Q>
function _ZN3glm6lookAtIfLNS_9qualifierE0EEENS_3matILi4ELi4ET_XT0_EEERKNS_3vecILi3ES3_XT0_EEES8_S8_ called 2 returned 100% blocks executed 100%
        2:  145:	GLM_FUNC_QUALIFIER mat<4, 4, T, Q> lookAt(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
        2:  145-block  0
        -:  146:	{
        -:  147:		GLM_IF_CONSTEXPR(GLM_CONFIG_CLIP_CONTROL & GLM_CLIP_CONTROL_LH_BIT)
        -:  148:			return lookAtLH(eye, center, up);
        -:  149:		else
        2:  150:			return lookAtRH(eye, center, up);
        2:  150-block  0
call    0 returned 2
        -:  151:	}
        -:  152:}//namespace glm
