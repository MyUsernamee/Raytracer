        -:    0:Source:/home/dihydromonoxide/vcpkg/installed/x64-linux/include/png++/generator.hpp
        -:    0:Graph:/home/dihydromonoxide/CLionProjects/Raytracer/cmake-build-debug-coverage/CMakeFiles/Raytracer.dir/src/World.cpp.gcno
        -:    0:Data:/home/dihydromonoxide/CLionProjects/Raytracer/cmake-build-debug-coverage/CMakeFiles/Raytracer.dir/src/World.cpp.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: * Copyright (C) 2007,2008   Alex Shulgin
        -:    3: *
        -:    4: * This file is part of png++ the C++ wrapper for libpng.  PNG++ is free
        -:    5: * software; the exact copying conditions are as follows:
        -:    6: *
        -:    7: * Redistribution and use in source and binary forms, with or without
        -:    8: * modification, are permitted provided that the following conditions are met:
        -:    9: *
        -:   10: * 1. Redistributions of source code must retain the above copyright notice,
        -:   11: * this list of conditions and the following disclaimer.
        -:   12: *
        -:   13: * 2. Redistributions in binary form must reproduce the above copyright
        -:   14: * notice, this list of conditions and the following disclaimer in the
        -:   15: * documentation and/or other materials provided with the distribution.
        -:   16: *
        -:   17: * 3. The name of the author may not be used to endorse or promote products
        -:   18: * derived from this software without specific prior written permission.
        -:   19: *
        -:   20: * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
        -:   21: * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
        -:   22: * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
        -:   23: * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        -:   24: * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
        -:   25: * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
        -:   26: * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
        -:   27: * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
        -:   28: * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   29: * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   30: */
        -:   31:#ifndef PNGPP_GENERATOR_HPP_INCLUDED
        -:   32:#define PNGPP_GENERATOR_HPP_INCLUDED
        -:   33:
        -:   34:#include <cassert>
        -:   35:#include <stdexcept>
        -:   36:#include <iostream>
        -:   37:#include <ostream>
        -:   38:
        -:   39:#include "config.hpp"
        -:   40:#include "error.hpp"
        -:   41:#include "streaming_base.hpp"
        -:   42:#include "writer.hpp"
        -:   43:
        -:   44:namespace png
        -:   45:{
        -:   46:
        -:   47:    /**
        -:   48:     * \brief Pixel generator class template.
        -:   49:     *
        -:   50:     * Used as a base class for custom pixel generator classes as well
        -:   51:     * as inside image class implementation to write pixels from the
        -:   52:     * pixel buffer.
        -:   53:     *
        -:   54:     * A usage example can be found in \c example/pixel_generator.cpp.
        -:   55:     *
        -:   56:     * Encapsulates PNG %image writing procedure.  In order to create
        -:   57:     * a custom pixel %generator use CRTP trick:
        -:   58:     *
        -:   59:     * \code
        -:   60:     * class pixel_generator
        -:   61:     *     : public png::generator< pixel, pixel_generator >
        -:   62:     * {
        -:   63:     *     ...
        -:   64:     * };
        -:   65:     * \endcode
        -:   66:     *
        -:   67:     * Your pixel %generator class should implement \c get_next_row()
        -:   68:     * method and \c reset() method (optional).  Their signatures are
        -:   69:     * as follows:
        -:   70:     *
        -:   71:     * \code
        -:   72:     * png::byte* get_next_row(png::uint_32 pos);
        -:   73:     * void reset(size_t pass);
        -:   74:     * \endcode
        -:   75:     *
        -:   76:     * The \c get_next_row() method is called every time a new row of
        -:   77:     * %image data is needed by the writer.  The position of the row
        -:   78:     * being written is passed as \c pos parameter.  The \c pos takes
        -:   79:     * values from \c 0 to \c <image_height>-1 inclusively.  The
        -:   80:     * method should return the starting address of a row buffer
        -:   81:     * storing an appropriate amount of pixels (i.e. the width of the
        -:   82:     * %image being written).  The address should be casted to
        -:   83:     * png::byte* pointer type using \c reinterpret_cast<> or a
        -:   84:     * C-style cast.
        -:   85:     *
        -:   86:     * The optional \c reset() method is called every time the new
        -:   87:     * pass of interlaced %image processing starts.  The number of
        -:   88:     * interlace pass is avaiable as the only parameter of the method.
        -:   89:     * For non-interlaced images the method is called once prior to
        -:   90:     * any calls to \c get_next_row().  The value of \c 0 is passed
        -:   91:     * for the \c pass number.  You do not have to implement this
        -:   92:     * method unless you are going to support interlaced %image
        -:   93:     * generation.
        -:   94:     *
        -:   95:     * An optional template parameter \c info_holder encapsulated
        -:   96:     * image_info storage policy.  Please refer to consumer class
        -:   97:     * documentation for the detailed description of this parameter.
        -:   98:     *
        -:   99:     * An optional \c bool template parameter \c interlacing_supported
        -:  100:     * specifies whether writing interlacing images is supported by
        -:  101:     * your %generator class.  It defaults to \c false.  An attempt to
        -:  102:     * write an interlaced %image will result in throwing
        -:  103:     * \c std::logic_error.
        -:  104:     *
        -:  105:     * In order to fully support interlacing specify \c true for \c
        -:  106:     * interlacing_supported parameter and implement \c reset()
        -:  107:     * method.  You _must_ generate the same pixels for every pass to
        -:  108:     * get the correct PNG %image output.
        -:  109:     *
        -:  110:     * \see image, consumer
        -:  111:     */
        -:  112:    template< typename pixel,
        -:  113:              class pixgen,
        -:  114:              class info_holder = def_image_info_holder,
        -:  115:              bool interlacing_supported = false >
        -:  116:    class generator
        -:  117:        : public streaming_base< pixel, info_holder >
        -:  118:    {
        -:  119:    public:
        -:  120:        /**
        -:  121:         * \brief Writes an image to the stream.
        -:  122:         *
        -:  123:         * Essentially, this method constructs a writer object and
        -:  124:         * instructs it to write the image to the stream.  It handles
        -:  125:         * writing interlaced images as long as your generator class
        -:  126:         * supports this.
        -:  127:         */
        -:  128:        template< typename ostream >
function _ZN3png9generatorINS_15basic_rgb_pixelIhEENS_5imageIS2_NS_12pixel_bufferIS2_EEE15pixel_generatorENS_21image_info_ref_holderELb1EE5writeISt14basic_ofstreamIcSt11char_traitsIcEEEEvRT_ called 1 returned 100% blocks executed 83%
        1:  129:        void write(ostream& stream)
        -:  130:        {
        2:  131:            writer< ostream > wr(stream);
        1:  131-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  131-block  1
call    3 returned 1
    $$$$$:  131-block  2
call    4 never executed
        1:  132:            wr.set_image_info(this->get_info());
        1:  132-block  0
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
        1:  133:            wr.write_info();
        1:  133-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  134:
        -:  135:#if __BYTE_ORDER == __LITTLE_ENDIAN
        1:  136:            if (pixel_traits< pixel >::get_bit_depth() == 16)
        1:  136-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
        -:  137:            {
        -:  138:#ifdef PNG_WRITE_SWAP_SUPPORTED
    #####:  139:                wr.set_swap();
    %%%%%:  139-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  140:#else
        -:  141:                throw error("Cannot write 16-bit image: recompile with PNG_WRITE_SWAP_SUPPORTED.");
        -:  142:#endif
        -:  143:            }
        -:  144:#endif
        -:  145:
        -:  146:            size_t pass_count;
        1:  147:            if (this->get_info().get_interlace_type() != interlace_none)
        1:  147-block  0
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        -:  148:            {
        -:  149:#ifdef PNG_WRITE_INTERLACING_SUPPORTED
        -:  150:                if (interlacing_supported)
        -:  151:                {
    #####:  152:                    pass_count = wr.set_interlace_handling();
    %%%%%:  152-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  152-block  1
        -:  153:                }
        -:  154:                else
        -:  155:                {
        -:  156:                    throw std::logic_error("Cannot write interlaced image: generator does not support it.");
        -:  157:                }
        -:  158:#else
        -:  159:                throw error("Cannot write interlaced image: interlace handling disabled.");
        -:  160:#endif
        -:  161:            }
        -:  162:            else
        -:  163:            {
        1:  164:                pass_count = 1;
        1:  164-block  0
        -:  165:            }
        1:  166:            pixgen* pixel_gen = static_cast< pixgen* >(this);
        2:  167:            for (size_t pass = 0; pass < pass_count; ++pass)
        1:  167-block  0
        2:  167-block  1
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  167-block  2
        -:  168:            {
        1:  169:                pixel_gen->reset(pass);
        1:  169-block  0
call    0 returned 1
        -:  170:
      513:  171:                for (uint_32 pos = 0; pos < this->get_info().get_height(); ++pos)
      513:  171-block  0
call    0 returned 513
call    1 returned 513
branch  2 taken 512 (fallthrough)
branch  3 taken 1
      512:  171-block  1
        -:  172:                {
      512:  173:                    wr.write_row(pixel_gen->get_next_row(pos));
      512:  173-block  0
call    0 returned 512
branch  1 taken 512 (fallthrough)
branch  2 taken 0 (throw)
      512:  173-block  1
call    3 returned 512
branch  4 taken 512 (fallthrough)
branch  5 taken 0 (throw)
        -:  174:                }
        -:  175:            }
        -:  176:
        1:  177:            wr.write_end_info();
        1:  177-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  178:        }
        -:  179:
        -:  180:    protected:
        -:  181:        typedef streaming_base< pixel, info_holder > base;
        -:  182:
        -:  183:        /**
        -:  184:         * \brief Constructs a generator object using passed image_info
        -:  185:         * object to store image information.
        -:  186:         */
function _ZN3png9generatorINS_15basic_rgb_pixelIhEENS_5imageIS2_NS_12pixel_bufferIS2_EEE15pixel_generatorENS_21image_info_ref_holderELb1EEC2ERNS_10image_infoE called 1 returned 100% blocks executed 100%
        1:  187:        explicit generator(image_info& info)
        1:  188:            : base(info)
        1:  188-block  0
call    0 returned 1
        -:  189:        {
        1:  190:        }
        -:  191:
        -:  192:        /**
        -:  193:         * \brief Constructs a generator object prepared to generate
        -:  194:         * an image of specified width and height.
        -:  195:         */
        -:  196:        generator(size_t width, size_t height)
        -:  197:            : base(width, height)
        -:  198:        {
        -:  199:        }
        -:  200:    };
        -:  201:
        -:  202:} // namespace png
        -:  203:
        -:  204:#endif // PNGPP_GENERATOR_HPP_INCLUDED
